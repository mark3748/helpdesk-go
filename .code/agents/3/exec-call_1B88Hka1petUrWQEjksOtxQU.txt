# Improvement Checklist (Prioritized)

Track and check off pending improvements. Items are grouped by priority and reference files/areas to update. Keep this list current as work proceeds.

## High Priority

- [x] Harden filesystem object store to prevent path traversal in `cmd/api/app/app.go` (`FsObjectStore`). Align with safe path cleaning/prefix checks used in `cmd/api/main.go`’s `fsObjectStore`.
- [x] Fix `internal/sla/sla.go` DB loader bug (variable shadowing: `rows` vs `hrows`, incorrect defer). Add a unit test to cover holiday loading and ensure both query cursors close correctly.
- [x] Unify duplicated API composition: consolidate config, app wiring, and object store between `cmd/api/main.go` and modular packages (`cmd/api/app`, `cmd/api/auth`, feature handlers). Make `main.go` a thin bootstrapper.
- [x] Strengthen JWT/OIDC validation in `cmd/api/auth`: verify issuer (when configured) and enforce allowed signing algorithms; standard time-based claims validated by parser. Follow-up: audience config and clock skew.
- [x] Consolidate login cookie handling: prefer single `hd_auth` cookie with `HttpOnly`, `SameSite=Lax`, and `Secure` in prod; remove legacy `auth` cookie.
- [x] Ensure `cmd/api/handlers/events.go` compiles cleanly (brace/structure sanity) and matches tests; keep heartbeat/backpressure behavior intact.

Additional completions

- [x] Attachments: implement presign/finalize and internal upload flow in `cmd/api/attachments` and rewire routes; preserve MinIO redirect and filesystem serving; block traversal.
- [x] Tickets/Comments/Watchers/Metrics/Exports: rewire routes to modular handlers; remove legacy duplicates from `main.go`.
- [x] Auth: switch to `cmd/api/auth` middleware and role checks; remove legacy main auth handlers.
- [x] Align Go versions across codebase: `go.mod`, Dockerfiles, and CI (`.github/workflows/ci.yml`) to a single supported version.

## Medium Priority

- [ ] Standardize rate limiting: prefer Redis-backed limiter (`internal/ratelimit`) for login, ticket create, and attachments; remove ad‑hoc in‑memory limiter to ensure consistency across replicas.
- [ ] Add context timeouts to DB, Redis, MinIO, and JWKS operations; propagate request contexts to DB calls in handlers.
- [ ] Improve JWKS handling: periodic refresh with backoff/metrics; validate KID/alg robustly; fail closed with clear errors when JWKS unavailable.
- [x] Helm: move sensitive config to Kubernetes Secrets (DB URL, `AUTH_LOCAL_SECRET`, `SMTP_*`, `MINIO_*`); wire via `envFrom` in templates. Add `imagePullSecrets` and scheduling knobs. Add optional PVC for `FILESTORE_PATH`.
- [ ] Make Docker builds reproducible: vendor/pin Swagger UI assets instead of fetching at build time, or checksum‑verify downloads.
- [ ] Multi-arch builds: parameterize `GOARCH` and use Buildx matrix in CI for `linux/amd64,linux/arm64` images.
- [ ] Expand tests: path traversal attempts for object store; JWT claim validation; `s3` presign error paths; `/attachments/upload/:objectKey` validates keys; add SLA calendar loader tests (holidays/hours).
- [ ] Observability: unify structured request logging (use `cmd/api/app/middleware.go` logger everywhere), add Prometheus counters for ticket create/update, auth failures, and rate-limit rejections.
- [ ] Tighten CORS headers: minimize `Access-Control-Allow-Headers` to required set; keep `Vary: Origin`; document `ALLOWED_ORIGINS` usage and risks.

### Medium Implementation Plan (PR Checklist)

Tracking for the current branch `medium-priority-fixes`. See detailed stubs in `docs/plan-medium-prs.md`.

- [x] PR1 – Rate limiting standardization
  - [x] Ensure `internal/ratelimit` wraps: `POST /login`, `POST /tickets`, `POST /tickets/:id/attachments/presign`, `POST /tickets/:id/attachments`, `GET /tickets/:id/attachments/:attID` (download path gating optional)
  - [x] Remove any in‑memory limiters in modular handlers (confirm none remain)
  - [x] Add Prometheus counter `rate_limit_rejections_total{route=...}` and increment from limiter middleware
  - [x] Config notes: `RATE_LIMIT_LOGIN`, `RATE_LIMIT_TICKETS`, `RATE_LIMIT_ATTACHMENTS`
  - [x] Tests: burst requests hit 429 and counter increments

<<<<<<< HEAD
- [ ] PR2 – Context timeouts (phase 1: DB)
  - [ ] Add env knobs: `DB_TIMEOUT_MS`, default 5000
  - [ ] Wrap DB calls in handlers with `context.WithTimeout`
  - [ ] Tests: simulated slow DB returns 504/500 as appropriate (table‑driven)
=======
- [x] PR2 – Context timeouts (phase 1: DB)
  - [x] Add env knobs: `DB_TIMEOUT_MS`, default 5000
  - [x] Wrap DB calls in handlers with `context.WithTimeout` via `a.dbCtx(c)` helper
  - [x] Tests: simulated slow DB returns failure (readyz) using a slow DB stub
>>>>>>> dev/medium-priority-fixes

- [ ] PR3 – Timeouts (phase 2: Redis/MinIO) + upload key validation
  - [ ] Add `REDIS_TIMEOUT_MS` (2000) and `OBJECTSTORE_TIMEOUT_MS` (10000)
  - [ ] Apply to queue ops, limiter ping, presign/put/stat
  - [ ] Validate `/attachments/upload/:objectKey` requires UUID (return 400 otherwise)
  - [ ] Tests: Redis timeouts soft‑fail behavior; filesystem upload success + invalid key 400

- [ ] PR4 – JWKS hardening
  - [ ] Replace fixed ticker with jittered exponential backoff refresh; keep last‑good cache
  - [ ] Enforce allowed JWT algs; require/validate `kid` when present
  - [ ] Metrics: `jwks_refresh_total`, `jwks_refresh_errors_total`
  - [ ] `/readyz` fails when JWKS configured but cache empty
  - [ ] Tests: invalid alg/kid, clock skew, audience (when configured)

- [ ] PR5 – Reproducible Swagger UI assets
  - [ ] Vendor Swagger UI into `docker/swagger/` and COPY in `Dockerfile.api`
  - [ ] Remove any build‑time network fetches; checksum if download kept
  - [ ] Test: CI build offline; `/api/docs` serves UI

- [ ] PR6 – Multi‑arch Buildx CI
  - [ ] Update `.github/workflows/release.yml` to build `linux/amd64,linux/arm64`
  - [ ] Pass `--platform` via `docker/build-push-action`; parameterize `GOARCH`
  - [ ] Test: manifests created; push on tag

- [ ] PR7 – Observability counters
  - [ ] Counters: `tickets_created_total`, `tickets_updated_total`, `auth_failures_total`, `rate_limit_rejections_total`, `attachments_uploaded_total`
  - [ ] Increment at modular handler entry points
  - [ ] Tests: unit counter assertions with a test registry

- [ ] PR8 – CORS tightening
  - [ ] Restrict `Access-Control-Allow-Headers` to `Authorization, Content-Type, X-Requested-With`
  - [ ] Ensure `Vary: Origin` always set; 403 for disallowed origins
  - [ ] Docs: `ALLOWED_ORIGINS` risks and examples
  - [ ] Tests: OPTIONS preflight allowed/blocked

- [ ] PR9 – SLA tests expansion
  - [ ] Edge cases: holidays, non‑business hours, boundaries
  - [ ] Table‑driven tests in `internal/sla/*_test.go`


## Low Priority

- [ ] Worker SMTP: add STARTTLS/TLS support and dial/write timeouts; configurable `smtpSendMail` transport.
- [ ] Add a basic readiness/liveness indicator for the worker (e.g., Redis ping or lightweight HTTP endpoint) and wire probes if desired.
- [ ] Set default resource requests/limits in Helm for API, worker, and frontends; add examples in `helm/helpdesk/examples`.
- [ ] Provide Makefile targets for common workflows (`build`, `test`, `docker`, `lint-helm`).
- [ ] Documentation: expand auth modes section (cookie name/flags, OIDC claims), rate limiting behavior/dependencies, and deployment hardening tips.

## Notes

- Keep items scoped and linked to PRs. For multi-part refactors (e.g., unifying `main.go` with modular packages), split into small PRs to ease review.

## Recently Completed (This PR)

- [x] Ticket creation deduplication: Redis idempotency (resilient to Redis errors), DB advisory locks, and exact-content unique index (migration cleans existing dupes).
- [x] SSE stability: initial heartbeat and `X-Accel-Buffering: no`; graceful fallback when `http.Flusher` absent.
- [x] UI gating for attachments: `GET /api/features` exposes `attachments` flag; internal UI disables upload button with message when storage is not configured.
- [x] Helm: Secrets support (`values.secrets` + optional managed Secret), `imagePullSecrets`, `nodeSelector`/`tolerations`/`affinity`, and `persistence.enabled` PVC mounted at `FILESTORE_PATH`.
- [x] Tickets: return `201 Created` on success; include `description` in list/detail; auto-assign for `agent`/`admin` creators.
---
=== cmd/api/main.go ===
package main

import (
    "bytes"
    "context"
    "crypto/rand"
    "crypto/sha256"
    "database/sql"
	"embed"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"strconv"
	"strings"
    "time"

    "github.com/gin-gonic/gin"
    "github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgxpool"
	_ "github.com/jackc/pgx/v5/stdlib"
	"github.com/joho/godotenv"
	"github.com/lestrrat-go/jwx/v2/jwk"
	"github.com/minio/minio-go/v7"
	"github.com/minio/minio-go/v7/pkg/credentials"
    "github.com/pressly/goose/v3"
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promhttp"
    "github.com/redis/go-redis/v9"
    "github.com/rs/zerolog"
    "github.com/rs/zerolog/log"
    "golang.org/x/crypto/bcrypt"

    appcore "github.com/mark3748/helpdesk-go/cmd/api/app"
    appevents "github.com/mark3748/helpdesk-go/cmd/api/events"
    handlers "github.com/mark3748/helpdesk-go/cmd/api/handlers"
    authpkg "github.com/mark3748/helpdesk-go/cmd/api/auth"
    userspkg "github.com/mark3748/helpdesk-go/cmd/api/users"
    roles "github.com/mark3748/helpdesk-go/cmd/api/roles"
    ticketspkg "github.com/mark3748/helpdesk-go/cmd/api/tickets"
    commentspkg "github.com/mark3748/helpdesk-go/cmd/api/comments"
    attachmentspkg "github.com/mark3748/helpdesk-go/cmd/api/attachments"
    watcherspkg "github.com/mark3748/helpdesk-go/cmd/api/watchers"
    metricspkg "github.com/mark3748/helpdesk-go/cmd/api/metrics"
    exportspkg "github.com/mark3748/helpdesk-go/cmd/api/exports"
    rateln "github.com/mark3748/helpdesk-go/internal/ratelimit"
    "sync"
)

//go:embed migrations/*.sql
var migrationsFS embed.FS

// openapi.yaml is served from disk to avoid cross-package embed limitations.

// Serve Swagger UI locally to avoid external CDN dependency.
var swaggerHTML = `<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Helpdesk API Docs</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" type="text/css" href="/swagger/swagger-ui.css" />
    <style>body { margin: 0; padding: 0; }</style>
  </head>
  <body>
    <div id="swagger-ui"></div>
    <script src="/swagger/swagger-ui-bundle.js" charset="UTF-8"></script>
    <script src="/swagger/swagger-ui-standalone-preset.js" charset="UTF-8"></script>
    <script>
      window.onload = () => {
        window.ui = SwaggerUIBundle({
          url: '/openapi.yaml',
          dom_id: '#swagger-ui',
          presets: [SwaggerUIBundle.presets.apis, SwaggerUIStandalonePreset],
          layout: 'StandaloneLayout'
        });
      };
    </script>
  </body>
</html>`

var (
	statusEnum   = []string{"New", "Open", "Pending", "Resolved", "Closed"}
	sourceEnum   = []string{"web", "email"}
	priorityEnum = []int16{1, 2, 3, 4}
)

var (
    rlRejects = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "rate_limit_rejections_total",
            Help: "Number of requests rejected by rate limiting.",
        },
        []string{"route"},
    )
    metricsRegisterOnce sync.Once
)

func enumContains[T comparable](list []T, v T) bool {
	for _, e := range list {
		if e == v {
			return true
		}
	}
	return false
}

type Config struct {
	Addr           string
	DatabaseURL    string
	Env            string
	RedisAddr      string
	OIDCIssuer     string
	JWKSURL        string
	OIDCGroupClaim string
	MinIOEndpoint  string
	MinIOAccess    string
	MinIOSecret    string
	MinIOBucket    string
	MinIOUseSSL    bool
	AllowedOrigins []string
	// Testing helpers
	TestBypassAuth bool
	// Local auth
	AuthMode        string // "oidc" or "local"
	AuthLocalSecret string
	// Filesystem object store for dev/local
	FileStorePath       string
	OpenAPISpecPath     string
	LogPath             string
	LoginRateLimit      int
	TicketRateLimit     int
    AttachmentRateLimit int
    // Optional OIDC audience validation and JWT clock skew
    OIDCAudience       string
    JWTClockSkewSeconds int
    // Timeouts
    DBTimeoutMS        int
}

func getConfig() Config {
	_ = godotenv.Load()
	cfg := Config{
		Addr:           getEnv("ADDR", ":8080"),
		DatabaseURL:    getEnv("DATABASE_URL", "postgres://postgres:postgres@localhost:5432/helpdesk?sslmode=disable"),
		Env:            getEnv("ENV", "dev"),
		RedisAddr:      getEnv("REDIS_ADDR", "localhost:6379"),
		OIDCIssuer:     getEnv("OIDC_ISSUER", ""),
		JWKSURL:        getEnv("OIDC_JWKS_URL", ""),
		OIDCGroupClaim: getEnv("OIDC_GROUP_CLAIM", "groups"),
		MinIOEndpoint:  getEnv("MINIO_ENDPOINT", ""),
		MinIOAccess:    getEnv("MINIO_ACCESS_KEY", ""),
		MinIOSecret:    getEnv("MINIO_SECRET_KEY", ""),
		MinIOBucket:    getEnv("MINIO_BUCKET", "attachments"),
		MinIOUseSSL:    getEnv("MINIO_USE_SSL", "false") == "true",
		AllowedOrigins: func() []string {
			v := getEnv("ALLOWED_ORIGINS", "")
			if v == "" {
				return nil
			}
			parts := strings.Split(v, ",")
			out := make([]string, 0, len(parts))
			for _, p := range parts {
				if s := strings.TrimSpace(p); s != "" {
					out = append(out, s)
				}
			}
			return out
		}(),
		TestBypassAuth:      getEnv("TEST_BYPASS_AUTH", "false") == "true",
		AuthMode:            getEnv("AUTH_MODE", "oidc"),
		AuthLocalSecret:     getEnv("AUTH_LOCAL_SECRET", ""),
		FileStorePath:       getEnv("FILESTORE_PATH", ""),
		OpenAPISpecPath:     getEnv("OPENAPI_SPEC_PATH", ""),
		LogPath:             getEnv("LOG_PATH", "/config/logs"),
		LoginRateLimit:      getEnvInt("RATE_LIMIT_LOGIN", 0),
		TicketRateLimit:     getEnvInt("RATE_LIMIT_TICKETS", 0),
        AttachmentRateLimit: getEnvInt("RATE_LIMIT_ATTACHMENTS", 0),
        OIDCAudience:         getEnv("OIDC_AUDIENCE", ""),
        JWTClockSkewSeconds:  getEnvInt("JWT_CLOCK_SKEW_SECONDS", 0),
        DBTimeoutMS:          getEnvInt("DB_TIMEOUT_MS", 5000),
    }
    return cfg
}

func getEnv(key, def string) string {
	if v := os.Getenv(key); v != "" {
		return v
	}
	return def
}

func getEnvInt(key string, def int) int {
	if v := os.Getenv(key); v != "" {
		if i, err := strconv.Atoi(v); err == nil {
			return i
		}
	}
	return def
}

func mkdirWithFallback(path, fallback, env, warnMsg, fatalMsg string) string {
	if err := os.MkdirAll(path, 0o755); err != nil {
		if env == "dev" {
			if err2 := os.MkdirAll(fallback, 0o755); err2 == nil {
				log.Warn().Err(err).Str("path", path).Str("fallback", fallback).Msg(warnMsg)
				return fallback
			}
		}
		log.Fatal().Err(err).Str("path", path).Msg(fatalMsg)
	}
	return path
}

// DB is a minimal interface to allow mocking in tests.
type DB interface {
	Query(ctx context.Context, sql string, args ...interface{}) (pgx.Rows, error)
	QueryRow(ctx context.Context, sql string, args ...interface{}) pgx.Row
	Exec(ctx context.Context, sql string, args ...interface{}) (pgconn.CommandTag, error)
}

// ObjectStore wraps the subset of MinIO we need for tests.
type ObjectStore interface {
    PutObject(ctx context.Context, bucketName, objectName string, reader io.Reader, objectSize int64, opts minio.PutObjectOptions) (minio.UploadInfo, error)
    RemoveObject(ctx context.Context, bucketName, objectName string, opts minio.RemoveObjectOptions) error
    PresignedPutObject(ctx context.Context, bucketName, objectName string, expiry time.Duration) (*url.URL, error)
    StatObject(ctx context.Context, bucketName, objectName string, opts minio.StatObjectOptions) (minio.ObjectInfo, error)
}

// Note: Filesystem object store is provided by appcore.FsObjectStore when MinIO is not configured.

---

type App struct {
	cfg  Config
	db   DB
	r    *gin.Engine
	keyf jwt.Keyfunc
	m    ObjectStore
	q    *redis.Client
	// pingRedis allows overriding Redis health check in tests
	pingRedis func(ctx context.Context) error
	loginRL   *rateln.Limiter
	ticketRL  *rateln.Limiter
	attRL     *rateln.Limiter
}

// core returns a lightweight adapter to the modular app.App for feature handlers.
func (a *App) core() *appcore.App {
    // Map required fields so modular handlers (auth, etc.) receive the same config.
    cfg := appcore.Config{
        // Environment and testing
        Env:                a.cfg.Env,
        TestBypassAuth:     a.cfg.TestBypassAuth,
        // Auth configuration
        AuthMode:           a.cfg.AuthMode,
        AuthLocalSecret:    a.cfg.AuthLocalSecret,
        AdminPassword:      os.Getenv("ADMIN_PASSWORD"),
        OIDCIssuer:         a.cfg.OIDCIssuer,
        OIDCGroupClaim:     a.cfg.OIDCGroupClaim,
        OIDCAudience:       a.cfg.OIDCAudience,
        JWTClockSkewSeconds: a.cfg.JWTClockSkewSeconds,
        // Object storage
        MinIOBucket:        a.cfg.MinIOBucket,
        MinIOEndpoint:      a.cfg.MinIOEndpoint,
        MinIOUseSSL:        a.cfg.MinIOUseSSL,
        // Filesystem store path (used by FsObjectStore when MinIO is not set)
        FileStorePath:      a.cfg.FileStorePath,
        LogPath:            a.cfg.LogPath,
    }
    return &appcore.App{Cfg: cfg, DB: a.db, R: a.r, Keyf: a.keyf, M: a.m, Q: a.q}
}

// dbCtx returns a child context with the configured DB timeout applied.
// If no timeout is configured or the request already has an earlier deadline,
// it returns the original context.
func (a *App) dbCtx(c *gin.Context) (context.Context, context.CancelFunc) {
    base := c.Request.Context()
    if a.cfg.DBTimeoutMS <= 0 {
        return base, func() {}
    }
    timeout := time.Duration(a.cfg.DBTimeoutMS) * time.Millisecond
    if dl, ok := base.Deadline(); ok {
        remain := time.Until(dl)
        if remain > 0 && remain < timeout {
            return context.WithTimeout(base, remain)
        }
    }
    return context.WithTimeout(base, timeout)
}

// settingsDB adapts this package's DB interface to the handlers.DB interface
type settingsDB struct{ db DB }

type noopRow struct{}

func (n *noopRow) Scan(dest ...any) error { return pgx.ErrNoRows }

func (s settingsDB) QueryRow(ctx context.Context, sql string, args ...any) pgx.Row {
	if s.db == nil {
		return &noopRow{}
	}
	return s.db.QueryRow(ctx, sql, args...)
}
func (s settingsDB) Exec(ctx context.Context, sql string, args ...any) (pgconn.CommandTag, error) {
	if s.db == nil {
		return pgconn.CommandTag{}, nil
	}
	return s.db.Exec(ctx, sql, args...)
}

// NewApp constructs an App with injected dependencies and registers routes.
func NewApp(cfg Config, db DB, keyf jwt.Keyfunc, store ObjectStore, q *redis.Client) *App {
    if db != nil && cfg.DBTimeoutMS > 0 {
        db = &dbWithTimeout{inner: db, timeout: time.Duration(cfg.DBTimeoutMS) * time.Millisecond}
    }
    a := &App{cfg: cfg, db: db, r: gin.New(), keyf: keyf, m: store, q: q}
	if q != nil {
		a.pingRedis = func(ctx context.Context) error { return q.Ping(ctx).Err() }
		if cfg.LoginRateLimit > 0 {
			a.loginRL = rateln.New(q, cfg.LoginRateLimit, time.Minute, "login:")
		}
		if cfg.TicketRateLimit > 0 {
			a.ticketRL = rateln.New(q, cfg.TicketRateLimit, time.Minute, "tickets:")
		}
		if cfg.AttachmentRateLimit > 0 {
			a.attRL = rateln.New(q, cfg.AttachmentRateLimit, time.Minute, "attachments:")
		}
	}
	if cfg.Env != "test" && db != nil {
		handlers.InitSettings(context.Background(), settingsDB{db: db}, cfg.LogPath)
	}
	handlers.EnqueueEmail = a.enqueueEmail
    a.r.Use(gin.Recovery())
    // Structured logging with request IDs
    a.r.Use(appcore.RequestID())
    a.r.Use(appcore.Logger())
	a.r.Use(func(c *gin.Context) {
		c.Header("Content-Security-Policy", "default-src 'none'")
		c.Header("X-Content-Type-Options", "nosniff")
		origin := c.GetHeader("Origin")
		if origin != "" && len(cfg.AllowedOrigins) > 0 {
			allowed := false
			for _, ao := range cfg.AllowedOrigins {
				if origin == ao {
					allowed = true
					break
				}
			}
			if !allowed {
				c.AbortWithStatus(http.StatusForbidden)
				return
			}
			// CORS headers for allowed origins
			c.Header("Access-Control-Allow-Origin", origin)
			c.Header("Vary", "Origin")
			c.Header("Access-Control-Allow-Methods", "GET, POST, PATCH, PUT, DELETE, OPTIONS")
			c.Header("Access-Control-Allow-Headers", "Authorization, Content-Type, X-Requested-With")
			c.Header("Access-Control-Allow-Credentials", "true")
			// Handle preflight requests
			if c.Request.Method == http.MethodOptions {
				c.Status(http.StatusNoContent)
				c.Abort()
				return
			}
		}
		c.Next()
	})
    a.routes()
    return a
}

<<<<<<< HEAD
=======
// dbWithTimeout decorates DB calls with a per-call timeout derived from config.
type dbWithTimeout struct {
    inner   DB
    timeout time.Duration
}

func (w *dbWithTimeout) with(ctx context.Context) (context.Context, context.CancelFunc) {
    if w.timeout <= 0 {
        return ctx, func() {}
    }
    if dl, ok := ctx.Deadline(); ok {
        remain := time.Until(dl)
        if remain > 0 && remain < w.timeout {
            return context.WithTimeout(ctx, remain)
        }
    }
    return context.WithTimeout(ctx, w.timeout)
}

func (w *dbWithTimeout) Query(ctx context.Context, sql string, args ...interface{}) (pgx.Rows, error) {
    c, cancel := w.with(ctx)
    defer cancel()
    return w.inner.Query(c, sql, args...)
}

func (w *dbWithTimeout) QueryRow(ctx context.Context, sql string, args ...interface{}) pgx.Row {
    c, _ := w.with(ctx)
    return w.inner.QueryRow(c, sql, args...)
}

func (w *dbWithTimeout) Exec(ctx context.Context, sql string, args ...interface{}) (pgconn.CommandTag, error) {
    c, cancel := w.with(ctx)
    defer cancel()
    return w.inner.Exec(c, sql, args...)
}

>>>>>>> dev/medium-priority-fixes
// rlMiddleware wraps a ratelimit.Limiter to record Prometheus counters on rejection.
func (a *App) rlMiddleware(l *rateln.Limiter, keyFunc func(*gin.Context) string, route string) gin.HandlerFunc {
    if l == nil { return func(c *gin.Context) { c.Next() } }
    // Register metrics once
    metricsRegisterOnce.Do(func(){ prometheus.MustRegister(rlRejects) })
    return func(c *gin.Context) {
        key := keyFunc(c)
        ok, err := l.Allow(c.Request.Context(), key)
        if err != nil || !ok {
            rlRejects.WithLabelValues(route).Inc()
            c.AbortWithStatusJSON(http.StatusTooManyRequests, gin.H{"error": "rate limited"})
            return
        }
        c.Next()
    }
}

func main() {
	cfg := getConfig()
	writer := io.Writer(os.Stdout)
	if cfg.Env == "dev" {
		writer = zerolog.ConsoleWriter{Out: os.Stdout, TimeFormat: time.RFC3339}
		gin.SetMode(gin.DebugMode)
	} else {
		gin.SetMode(gin.ReleaseMode)
	}
	if err := os.MkdirAll(cfg.LogPath, 0o755); err != nil {
		log.Warn().Err(err).Str("dir", cfg.LogPath).Msg("using stdout for logs")
	} else {
		logFile := filepath.Join(cfg.LogPath, "api.log")
		f, err := os.OpenFile(logFile, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0o644)
		if err != nil {
			log.Warn().Err(err).Str("path", logFile).Msg("using stdout for logs")
		} else {
			if cfg.Env == "dev" {
				writer = zerolog.MultiLevelWriter(f, writer)
			} else {
				writer = f
			}
			defer f.Close()
		}
	}
	log.Logger = zerolog.New(writer).With().Timestamp().Logger()

	// DB connect
	ctx := context.Background()
	pool, err := pgxpool.New(ctx, cfg.DatabaseURL)
	if err != nil {
		log.Fatal().Err(err).Msg("db connect")
	}
	defer pool.Close()

	// Migrate (embedded goose) using pgx stdlib driver
	goose.SetBaseFS(migrationsFS)
	if err := goose.SetDialect("postgres"); err != nil {
		log.Fatal().Err(err).Msg("goose dialect")
	}
	sqldb, err := sql.Open("pgx", cfg.DatabaseURL)
	if err != nil {
		log.Fatal().Err(err).Msg("sql open for goose")
	}
	defer sqldb.Close()
	if err := goose.UpContext(ctx, sqldb, "migrations"); err != nil {
		log.Fatal().Err(err).Msg("migrate up")
	}

	// JWKS-backed Keyfunc
	var keyf jwt.Keyfunc
	if cfg.JWKSURL != "" {
		// Fetch JWKS on startup and refresh periodically
		httpClient := &http.Client{Timeout: 10 * time.Second}
		set, err := jwk.Fetch(ctx, cfg.JWKSURL, jwk.WithHTTPClient(httpClient))
		if err != nil {
			log.Fatal().Err(err).Str("jwks_url", cfg.JWKSURL).Msg("fetch jwks")
		}
		// simple periodic refresh
		setPtr := &set
		go func() {
			ticker := time.NewTicker(10 * time.Minute)
			defer ticker.Stop()
			for range ticker.C {
				if newSet, err := jwk.Fetch(context.Background(), cfg.JWKSURL, jwk.WithHTTPClient(httpClient)); err == nil {
					*setPtr = newSet
				}
			}
		}()
		keyf = func(t *jwt.Token) (interface{}, error) {
			kid, _ := t.Header["kid"].(string)
			if kid != "" {
				if key, ok := (*setPtr).LookupKeyID(kid); ok {
					var pub any
					if err := key.Raw(&pub); err != nil {
						return nil, err
					}
					return pub, nil
				}
			}
			// fallback: use the first key in the set
			it := (*setPtr).Iterate(context.Background())
			if it.Next(context.Background()) {
				pair := it.Pair()
				if key, ok := pair.Value.(jwk.Key); ok {
---
				if key, ok := pair.Value.(jwk.Key); ok {
					var pub any
					if err := key.Raw(&pub); err != nil {
						return nil, err
					}
					return pub, nil
				}
			}
			return nil, fmt.Errorf("no jwk for kid: %s", kid)
		}
	}

	var mc *minio.Client
	if cfg.MinIOEndpoint != "" {
		mc, err = minio.New(cfg.MinIOEndpoint, &minio.Options{
			Creds:  credentials.NewStaticV4(cfg.MinIOAccess, cfg.MinIOSecret, ""),
			Secure: cfg.MinIOUseSSL,
		})
		if err != nil {
			log.Fatal().Err(err).Msg("minio init")
		}
	}

	// Redis client (optional)
	var rdb *redis.Client
	if cfg.RedisAddr != "" {
		rdb = redis.NewClient(&redis.Options{Addr: cfg.RedisAddr})
		if err := rdb.Ping(ctx).Err(); err != nil {
			log.Error().Err(err).Msg("redis ping")
		}
		defer rdb.Close()
	}

	var store ObjectStore
	if mc != nil {
		store = mc
    } else if cfg.FileStorePath != "" {
        base := mkdirWithFallback(
            cfg.FileStorePath,
            filepath.Join(os.TempDir(), "helpdesk-data"),
            cfg.Env,
            "using /tmp filestore path",
            "create filestore path",
        )
        if cfg.MinIOBucket != "" {
            bucketPath := filepath.Join(base, cfg.MinIOBucket)
            bucketPath = mkdirWithFallback(
                bucketPath,
                filepath.Join(os.TempDir(), "helpdesk-data", cfg.MinIOBucket),
                cfg.Env,
                "using /tmp filestore bucket path",
                "create filestore bucket path",
            )
            base = filepath.Dir(bucketPath)
        }
        cfg.FileStorePath = base
        store = &appcore.FsObjectStore{Base: base}
    }

	// Seed a dev admin for local auth
	if cfg.AuthMode == "local" && cfg.Env == "dev" {
		if err := seedLocalAdmin(context.Background(), pool); err != nil {
			log.Error().Err(err).Msg("seed local admin")
		}
	}

	a := NewApp(cfg, pool, keyf, store, rdb)

	srv := &http.Server{
		Addr:           cfg.Addr,
		Handler:        a.r,
		ReadTimeout:    15 * time.Second,
		WriteTimeout:   15 * time.Second,
		MaxHeaderBytes: 1 << 20,
	}
	log.Info().Str("addr", cfg.Addr).Msg("api listening")
	if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
		log.Fatal().Err(err).Msg("listen")
	}
}

func (a *App) routes() {
    // In production, expose API only under /api to avoid duplicate routing via
    // proxies/ingress that might forward both / and /api to the backend. In
    // dev and test, keep both for convenience and backward-compat tests.
    if a.cfg.Env == "prod" {
        a.mountAPI(a.r.Group("/api"))
        // Provide top-level health endpoints commonly used by probes
        a.r.GET("/livez", func(c *gin.Context) { c.JSON(200, gin.H{"ok": true}) })
        a.r.GET("/readyz", a.readyz)
        a.r.GET("/healthz", func(c *gin.Context) { c.JSON(200, gin.H{"ok": true}) })
    } else {
        a.mountAPI(a.r.Group(""))
        a.mountAPI(a.r.Group("/api"))
    }
}

func (a *App) mountAPI(rg *gin.RouterGroup) {
	rg.GET("/livez", func(c *gin.Context) { c.JSON(200, gin.H{"ok": true}) })
	rg.GET("/readyz", a.readyz)
	rg.GET("/healthz", func(c *gin.Context) { c.JSON(200, gin.H{"ok": true}) })
	rg.GET("/csat/:token", a.csatForm)
	rg.POST("/csat/:token", a.submitCSAT)
	rg.GET("/metrics", gin.WrapH(promhttp.Handler()))
	// API docs UI and spec
	// Serve bundled Swagger UI assets from container image
	rg.Static("/swagger", "/opt/helpdesk/swagger")
	rg.GET("/docs", a.docsUI)
	rg.GET("/openapi.yaml", a.openapiSpec)
	// Local auth endpoints
    if a.cfg.AuthMode == "local" {
        if a.loginRL != nil {
            rg.POST("/login", a.rlMiddleware(a.loginRL, func(c *gin.Context) string { return c.ClientIP() }, "login"), authpkg.Login(a.core()))
            rg.POST("/logout", a.rlMiddleware(a.loginRL, func(c *gin.Context) string { return c.ClientIP() }, "logout"), authpkg.Logout())
        } else {
            rg.POST("/login", authpkg.Login(a.core()))
            rg.POST("/logout", authpkg.Logout())
        }
    }

    // Use an empty subpath to avoid introducing a double slash (e.g., 
    // "/api//me"). The UI expects endpoints like "/api/me".
    auth := rg.Group("")
    auth.Use(authpkg.Middleware(a.core()))
    auth.GET("/me", authpkg.Me)
	// User settings (profile + password)
	auth.GET("/me/profile", a.getMyProfile)
	auth.PATCH("/me/profile", a.updateMyProfile)
	auth.POST("/me/password", a.changeMyPassword)
	auth.GET("/events", handlers.Events(a.q))

    auth.GET("/settings", authpkg.RequireRole("admin"), handlers.GetSettings)
    auth.GET("/features", handlers.Features(a.core()))
    auth.POST("/test-connection", authpkg.RequireRole("admin"), handlers.TestConnection)
    auth.POST("/settings/storage", authpkg.RequireRole("admin"), handlers.SaveStorageSettings)
    auth.POST("/settings/oidc", authpkg.RequireRole("admin"), handlers.SaveOIDCSettings)
    auth.POST("/settings/mail", authpkg.RequireRole("admin"), handlers.SaveMailSettings)
    auth.POST("/settings/mail/send-test", authpkg.RequireRole("admin"), handlers.SendTestMail)

    auth.GET("/users/:id/roles", authpkg.RequireRole("admin"), authpkg.ListUserRoles(a.core()))
    auth.POST("/users/:id/roles", authpkg.RequireRole("admin"), authpkg.AddUserRole(a.core()))
    auth.DELETE("/users/:id/roles/:role", authpkg.RequireRole("admin"), authpkg.RemoveUserRole(a.core()))
	// Admin user management
    auth.GET("/users", authpkg.RequireRole("admin"), userspkg.List(a.core()))
    auth.GET("/users/:id", authpkg.RequireRole("admin"), userspkg.Get(a.core()))
    auth.POST("/users", authpkg.RequireRole("admin"), userspkg.CreateLocal(a.core()))
    auth.GET("/roles", authpkg.RequireRole("admin"), roles.List(a.core()))

    auth.GET("/requesters/:id", a.getRequester)
    auth.POST("/requesters", authpkg.RequireRole("agent", "manager"), a.createRequester)
    auth.PATCH("/requesters/:id", authpkg.RequireRole("agent", "manager"), a.updateRequester)

	// Tickets
    auth.GET("/tickets", ticketspkg.List(a.core()))
    if a.ticketRL != nil {
        auth.POST("/tickets", a.rlMiddleware(a.ticketRL, func(c *gin.Context) string {
            u := c.MustGet("user").(AuthUser)
            return u.ID
        }, "tickets_create"), ticketspkg.Create(a.core()))
    } else {
        auth.POST("/tickets", ticketspkg.Create(a.core()))
    }
    auth.GET("/tickets/:id", ticketspkg.Get(a.core()))
    auth.PATCH("/tickets/:id", authpkg.RequireRole("agent", "manager"), ticketspkg.Update(a.core()))
    auth.GET("/tickets/:id/comments", commentspkg.List(a.core()))
    auth.POST("/tickets/:id/comments", commentspkg.Add(a.core()))
    auth.GET("/tickets/:id/attachments", attachmentspkg.List(a.core()))
    if a.attRL != nil {
        auth.POST("/tickets/:id/attachments/presign", a.rlMiddleware(a.attRL, func(c *gin.Context) string {
            u := c.MustGet("user").(AuthUser)
            return u.ID
        }, "attachments_presign"), attachmentspkg.Presign(a.core()))
        auth.POST("/tickets/:id/attachments", a.rlMiddleware(a.attRL, func(c *gin.Context) string {
            u := c.MustGet("user").(AuthUser)
            return u.ID
        }, "attachments_finalize"), attachmentspkg.Finalize(a.core()))
        auth.GET("/tickets/:id/attachments/:attID", a.rlMiddleware(a.attRL, func(c *gin.Context) string {
            u := c.MustGet("user").(AuthUser)
            return u.ID
        }, "attachments_get"), attachmentspkg.Get(a.core()))
    } else {
        auth.POST("/tickets/:id/attachments/presign", attachmentspkg.Presign(a.core()))
        auth.POST("/tickets/:id/attachments", attachmentspkg.Finalize(a.core()))
        auth.GET("/tickets/:id/attachments/:attID", attachmentspkg.Get(a.core()))
    }
    // Internal upload endpoint used when filesystem store is enabled
    auth.PUT("/attachments/upload/:objectKey", attachmentspkg.UploadObject(a.core()))
    auth.DELETE("/tickets/:id/attachments/:attID", attachmentspkg.Delete(a.core()))
    auth.GET("/tickets/:id/watchers", watcherspkg.List(a.core()))
    auth.POST("/tickets/:id/watchers", watcherspkg.Add(a.core()))
    auth.DELETE("/tickets/:id/watchers/:uid", watcherspkg.Remove(a.core()))
    auth.GET("/metrics/sla", authpkg.RequireRole("agent"), metricspkg.SLA(a.core()))
    auth.GET("/metrics/resolution", authpkg.RequireRole("agent"), metricspkg.Resolution(a.core()))
    auth.GET("/metrics/tickets", authpkg.RequireRole("agent"), metricspkg.TicketVolume(a.core()))
    // Compatibility for UI expectations
    auth.GET("/metrics/agent", authpkg.RequireRole("agent"), metricspkg.Agent(a.core()))
    auth.GET("/metrics/manager", authpkg.RequireRole("manager", "admin"), metricspkg.Manager(a.core()))
    auth.POST("/exports/tickets", authpkg.RequireRole("agent"), a.exportTicketsBridge)
    auth.GET("/exports/tickets/:job_id", authpkg.RequireRole("agent"), a.exportTicketsStatus)
}

func (a *App) docsUI(c *gin.Context) {
	c.Data(200, "text/html; charset=utf-8", []byte(swaggerHTML))
}

func (a *App) openapiSpec(c *gin.Context) {
	candidates := []string{}
	if a.cfg.OpenAPISpecPath != "" {
		candidates = append(candidates, a.cfg.OpenAPISpecPath)
	}
	// Common defaults for dev and container images
	candidates = append(candidates, "docs/openapi.yaml", "/opt/helpdesk/docs/openapi.yaml")
	for _, p := range candidates {
		b, err := os.ReadFile(p)
		if err == nil {
			c.Data(200, "application/yaml", b)
			return
		}
	}
	c.JSON(404, gin.H{"error": "openapi spec not found"})
}

func (a *App) readyz(c *gin.Context) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

    if a.db != nil {
        var n int
        cctx, cancel := context.WithTimeout(ctx, time.Duration(a.cfg.DBTimeoutMS)*time.Millisecond)
        defer cancel()
        if err := a.db.QueryRow(cctx, "select 1").Scan(&n); err != nil {
            log.Error().Err(err).Msg("readyz db")
            c.JSON(500, gin.H{"error": "db"})
            return
        }
    }

	if a.pingRedis != nil {
		if err := a.pingRedis(ctx); err != nil {
			log.Error().Err(err).Msg("readyz redis")
			c.JSON(500, gin.H{"error": "redis"})
			return
		}
	}

    if a.m != nil {
        switch s := a.m.(type) {
        case *minio.Client:
            ok, err := s.BucketExists(ctx, a.cfg.MinIOBucket)
            if err != nil || !ok {
                log.Error().Err(err).Str("bucket", a.cfg.MinIOBucket).Msg("readyz minio")
                c.JSON(500, gin.H{"error": "object_store"})
                return
            }
        default:
            // Filesystem store: ensure directory exists and is writable
            dir := a.cfg.FileStorePath
            if fs, ok := a.m.(*appcore.FsObjectStore); ok && fs.Base != "" {
                dir = fs.Base
            }
            if a.cfg.MinIOBucket != "" {
                dir = filepath.Join(dir, a.cfg.MinIOBucket)
            }
            if err := os.MkdirAll(dir, 0o755); err != nil {
                log.Error().Err(err).Str("dir", dir).Msg("readyz filestore mkdir")
                c.JSON(500, gin.H{"error": "object_store"})
                return
            }
            testFile := filepath.Join(dir, ".readyz")
            if err := os.WriteFile(testFile, []byte("ok"), 0o644); err != nil {
                log.Error().Err(err).Msg("readyz filestore")
                c.JSON(500, gin.H{"error": "object_store"})
                return
            }
            _ = os.Remove(testFile)
        }
    }

	if ms := handlers.MailSettings(); ms != nil {
		host := ms["host"]
		port := ms["port"]
		if host == "" && port == "" {
			host = ms["smtp_host"]
			port = ms["smtp_port"]
		}
		if host != "" && port != "" {
			// In tests, simulate failure to avoid real network dials in CI sandboxes
			if a.cfg.Env == "test" {
				c.JSON(500, gin.H{"error": "smtp"})
				return
			}
			// Basic connectivity check only; do not send SMTP commands.
			conn, err := net.DialTimeout("tcp", net.JoinHostPort(host, port), 5*time.Second)
			if err != nil {
				log.Error().Err(err).Msg("readyz smtp")
				c.JSON(500, gin.H{"error": "smtp"})
				return
			}
			conn.Close()
		}
	}
